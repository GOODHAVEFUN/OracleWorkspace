-- 1. 축구 선수들 중에서 각 팀별로 키가 가장 큰 선수들의 전체 정보 조회

-- 위 문제를 JOIN 없이 풀기
-- (A, B) IN (C, D) : A = C AND B = D

SELECT P.*
FROM PLAYER P
WHERE (P.TEAM_ID, P.HEIGHT) IN (
  SELECT TEAM_ID, MAX(HEIGHT)
  FROM PLAYER
  GROUP BY TEAM_ID
);

-- 2. EMPLOYEES 테이블의 각 사원의 매니저의 직무 조회
SELECT E.FIRST_NAME, E.LAST_NAME, J.JOB_TITLE
FROM EMPLOYEES E
JOIN EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
JOIN JOBS J ON M.JOB_ID = J.JOB_ID;

-- 3. EMPLOYEES 테이블의 모든 사원의 이름과 부서명 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 4. EMPLOYEES 테이블에서 매니저가 없는 사원의 이름과 직무 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES e 
JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL;

-- 5. EMPLOYEES 테이블에서 직무별 평균 급여 조회
SELECT J.JOB_TITLE, AVG(E.SALARY)
FROM EMPLOYEES E, JOBS J
WHERE E.JOB_ID = J.JOB_ID
GROUP BY J.JOB_TITLE;

-- 6. EMPLOYEES 테이블에서 매니저별로 직속 직원 사원수 조회
SELECT M.FIRST_NAME, M.LAST_NAME, 
COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID = M.EMPLOYEE_ID -- 매니저 - 직원 관계매칭
GROUP BY M.FIRST_NAME, M.LAST_NAME;

CREATE  TABLE TBL_GRADE(
	GRADE_NUM NUMBER ,
	GRADE_NAME	VARCHAR2(1000),
	CONSTRAINT PK_GRADE_NUMBER PRIMARY KEY (GRADE_NUM)
);

CREATE TABLE TBL_USER_TEST(
USER_NUM NUMBER ,
USER_ID VARCHAR2(1000),
GRADE_NUM NUMBER ,
CONSTRAINT PK_USER_NUM PRIMARY KEY (USER_NUM),
CONSTRAINT FK_GRADE_NUM FOREIGN KEY(GRADE_NUM) REFERENCES TBL_GRADE(GRADE_NUM)
)

INSERT INTO TBL_GRADE VALUES(1,'VVIP');
INSERT INTO TBL_GRADE VALUES(2,'VIP');
INSERT INTO TBL_GRADE VALUES(3,'NORMAL');

INSERT INTO TBL_USER_TEST VALUES(1,'A',1);
INSERT INTO TBL_USER_TEST VALUES(2,'B',2);

SELECT *FROM TBL_GRADE ;
SELECT *FROM TBL_USER_TEST ;

SELECT *FROM TBL_GRADE G INNER JOIN TBL_USER_TEST U
ON G.GRADE_NUM= U.GRADE_NUM;

SELECT *FROM TBL_GRADE G LEFT OUTER JOIN TBL_USER_TEST U
ON G.GRADE_NUM= U.GRADE_NUM;
-- LEFT OUTER JOIN은 왼쪽 테이블(TBL_GRADE)의 모든 행을 포함하고
-- 조인 조건을 만족하는 경우 오른쪽 테이블(TBL_USER_TEST)의 행을 함께 반환함
-- 조인 조건을 만족하지 않는 경우 오른쪽 테이블의 NULL 채워짐

--형변환 함수
--TO_CHAR()

SELECT SYSDATE FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY.MM.DD') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY.MM.DD') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD-HH:MI:SS') FROM DUAL;

-- 숫자에 콤마 찍기
-- 형식보다 큰 자리수가 들어오면 데이터가 손상된다
-- 형식 지정시 0 또는 9를 사용하며
-- 9를 쓰면 값이 없을 때 공백이 들어간다
-- 0을 쓰면 값이 없을 때 0이 들어간다
-- FM을 형식 가장 왼쪽에 넣어주면 불필요한 공백을 없애준다

SELECT TO_CHAR(1234321, 'FM999,999,999')
FROM DUAL;

-- TO_NUMBER()
SELECT '1000'
FROM DUAL;

SELECT TO_NUMBER('1000')
FROM DUAL;

SELECT '1000' + '1000'
FROM DUAL;

-- TO_DATE()
SELECT '1900-01-02'
FROM DUAL;

SELECT TO_DATE('1900-01-02', 'YYYY-MM-DD')
FROM DUAL;

--집합
SELECT  * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 10;

SELECT  * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 30;

-- 두테이블을 합집합으로 연결한다
SELECT  * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 10
UNION 
SELECT  * 
FROM EMPLOYEES e 
WHERE DEPARTMENT_ID = 30;

-- UNION 중복 제거 확인
-- EMPLOYEES 테이블에서 SALARY 1500이상 3000이하 , 2500이상 5000이하 조회한다
SELECT  SALARY 
FROM EMPLOYEES e 
WHERE SALARY  BETWEEN  1500 AND 3000
UNION 
SELECT  SALARY  
FROM EMPLOYEES e 
WHERE SALARY  BETWEEN  2500 AND 5000
ORDER BY SALARY ;

SELECT  SALARY 
FROM EMPLOYEES e 
WHERE SALARY  BETWEEN  1500 AND 3000
UNION ALL
SELECT  SALARY  
FROM EMPLOYEES e 
WHERE SALARY  BETWEEN  2500 AND 5000
ORDER BY SALARY ;
-- UNION은 중복제거 작업을 추가로 하므로 UNION ALL보다 연산이 많아진다
-- 중복을 제거할 필요없다면 UNION  ALL을 사용하는 것이 효율적이다

SELECT * FROM EMPLOYEES e;
SELECT * FROM DEPARTMENTS d ;

--에러 : 열의 수가 다르면 UNION을 사용할수없다
SELECT * FROM EMPLOYEES e 
UNION
SELECT * FROM DEPARTMENTS d ;

-- 열의 타입이 일치하지않으면 UNION을 사용할수 없습니다
SELECT EMPLOYEE_ID , FIRST_NAME 
FROM EMPLOYEES e 
UNION
SELECT DEPARTMENT_ID ,MANAGER_ID 
FROM DEPARTMENTS d ;


--열의 개수와 열의 타입이 일치하면 UNION이 가능하다
SELECT EMP_NO 번호,EMP_NAME 직장 FROM TBL_EMP te  
UNION
SELECT DEPT_NO ,DEPT_NAME FROM TBL_DEPT td ;

SELECT EMP_NO 번호, EMP_NAME 이름, EMP_JOB 직장 FROM TBL_EMP te 
UNION
SELECT * FROM TBL_DEPT td 
ORDER BY EMP_NO ; --기존의 컬럼명으로 정렬시도시 오류 발생
--ORDER BY 번호 ;-- 정렬시 별칭을 사용한다

-- 교집합
SELECT PLAYER_NAME 이름, TEAM_ID 팀, HEIGHT 키, WEIGHT 몸무게
FROM PLAYER p 
WHERE HEIGHT BETWEEN  185 AND 186
INTERSECT 
SELECT PLAYER_NAME 이름, TEAM_ID 팀, HEIGHT 키, WEIGHT 몸무게
FROM PLAYER p 
WHERE WEIGHT  BETWEEN  76 AND 78;

-- 차집합
SELECT PLAYER_NAME 이름, TEAM_ID 팀, HEIGHT 키, WEIGHT 몸무게
FROM PLAYER p 
WHERE HEIGHT BETWEEN  185 AND 186
MINUS
SELECT PLAYER_NAME 이름, TEAM_ID 팀, HEIGHT 키, WEIGHT 몸무게
FROM PLAYER p 
WHERE WEIGHT  BETWEEN  78 AND 76;

--VIEW
--PLAYER  테이블에서 나이 컬럼을 추가한 뷰 만들기
 
SELECT * FROM  PLAYER p ;

SELECT P.*, SYSDATE  - BIRTH_DATE FROM PLAYER p ;
SELECT P.*, (SYSDATE  - BIRTH_DATE)/365 FROM PLAYER p ;
SELECT P.*, ROUND((SYSDATE  - BIRTH_DATE)/365) AGE FROM PLAYER p ;

CREATE VIEW VIEW_PLAYER AS SELECT P.*, ROUND((SYSDATE  - BIRTH_DATE)/365) AGE FROM PLAYER p ;

SELECT * FROM VIEW_PLAYER ;
SELECT AGE FROM VIEW_PLAYER ;

-- [실습 30분까지]
-- 1. EMPLOYEES 테이블에서 사원이름과 그 사원의 매니저이름이 있는 VIEW 만들기
-- 단, LAST_NAME과 FIRST_NAME 연결하기
-- (PK, FK는 없어지면 안됨)
SELECT 
	E.FIRST_NAME || ' ' || E.LAST_NAME 사원이름 ,
	M.FIRST_NAME || ' ' || M.LAST_NAME 메니저이름
FROM EMPLOYEES e 
JOIN EMPLOYEES M ON E.MANAGER_ID  =M.EMPLOYEE_ID 


-- 2. PLYAER 테이블에 TEAM_NAME 컬럼을 추가한 VIEW 만들기
 

