-- 1. 축구 선수들 중에서 각 팀별로 키가 가장 큰 선수들의 전체 정보 조회

-- 위 문제를 JOIN 없이 풀기
-- (A, B) IN (C, D) : A = C AND B = D

SELECT P.*
FROM PLAYER P
WHERE (P.TEAM_ID, P.HEIGHT) IN (
  SELECT TEAM_ID, MAX(HEIGHT)
  FROM PLAYER
  GROUP BY TEAM_ID
);

-- 2. EMPLOYEES 테이블의 각 사원의 매니저의 직무 조회
SELECT E.FIRST_NAME, E.LAST_NAME, J.JOB_TITLE
FROM EMPLOYEES E
JOIN EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
JOIN JOBS J ON M.JOB_ID = J.JOB_ID;

-- 3. EMPLOYEES 테이블의 모든 사원의 이름과 부서명 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 4. EMPLOYEES 테이블에서 매니저가 없는 사원의 이름과 직무 조회
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES e 
JOIN DEPARTMENTS d ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.MANAGER_ID IS NULL;

-- 5. EMPLOYEES 테이블에서 직무별 평균 급여 조회
SELECT J.JOB_TITLE, AVG(E.SALARY)
FROM EMPLOYEES E, JOBS J
WHERE E.JOB_ID = J.JOB_ID
GROUP BY J.JOB_TITLE;

-- 6. EMPLOYEES 테이블에서 매니저별로 직속 직원 사원수 조회
SELECT M.FIRST_NAME, M.LAST_NAME, 
COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID = M.EMPLOYEE_ID -- 매니저 - 직원 관계매칭
GROUP BY M.FIRST_NAME, M.LAST_NAME;

CREATE  TABLE TBL_GRADE(
	GRADE_NUM NUMBER ,
	GRADE_NAME	VARCHAR2(1000),
	CONSTRAINT PK_GRADE_NUMBER PRIMARY KEY (GRADE_NUM)
);

CREATE TABLE TBL_USER_TEST(
USER_NUM NUMBER ,
USER_ID VARCHAR2(1000),
GRADE_NUM NUMBER ,
CONSTRAINT PK_USER_NUM PRIMARY KEY (USER_NUM),
CONSTRAINT FK_GRADE_NUM FOREIGN KEY(GRADE_NUM) REFERENCES TBL_GRADE(GRADE_NUM)
)

INSERT INTO TBL_GRADE VALUES(1,'VVIP');
INSERT INTO TBL_GRADE VALUES(2,'VIP');
INSERT INTO TBL_GRADE VALUES(3,'NORMAL');

INSERT INTO TBL_USER_TEST VALUES(1,'A',1);
INSERT INTO TBL_USER_TEST VALUES(2,'B',2);

SELECT *FROM TBL_GRADE ;
SELECT *FROM TBL_USER_TEST ;

SELECT *FROM TBL_GRADE G INNER JOIN TBL_USER_TEST U
ON G.GRADE_NUM= U.GRADE_NUM;

SELECT *FROM TBL_GRADE G LEFT OUTER JOIN TBL_USER_TEST U
ON G.GRADE_NUM= U.GRADE_NUM;
-- LEFT OUTER JOIN은 왼쪽 테이블(TBL_GRADE)의 모든 행을 포함하고
-- 조인 조건을 만족하는 경우 오른쪽 테이블(TBL_USER_TEST)의 행을 함께 반환함
-- 조인 조건을 만족하지 않는 경우 오른쪽 테이블의 NULL 채워짐

--형변환 함수
--TO_CHAR()

SELECT SYSDATE FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY.MM.DD') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY.MM.DD') FROM DUAL;

SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD-HH:MI:SS') FROM DUAL;

-- 숫자에 콤마 찍기
-- 형식보다 큰 자리수가 들어오면 데이터가 손상된다
-- 형식 지정시 0 또는 9를 사용하며
-- 9를 쓰면 값이 없을 때 공백이 들어간다
-- 0을 쓰면 값이 없을 때 0이 들어간다
-- FM을 형식 가장 왼쪽에 넣어주면 불필요한 공백을 없애준다

SELECT TO_CHAR(1234321, 'FM999,999,999')
FROM DUAL;

-- TO_NUMBER()
SELECT '1000'
FROM DUAL;

SELECT TO_NUMBER('1000')
FROM DUAL;

SELECT '1000' + '1000'
FROM DUAL;

-- TO_DATE()
SELECT '1900-01-02'
FROM DUAL;

SELECT TO_DATE('1900-01-02', 'YYYY-MM-DD')
FROM DUAL;